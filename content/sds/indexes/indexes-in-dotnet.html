<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Indexes in .NET framework </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Indexes in .NET framework ">
    <meta name="generator" content="docfx 2.59.1.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    <meta property="docfx:rel" content="../../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../../../content/index.html" width="46">
                <img id="logo" src="../../../content/images/atlas_icon.png" height="46" width="46" alt="OSIsoft Edge Data Store"> 
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="IndexesInDotNet">
<h1 id="indexes-in-net-framework">Indexes in .NET framework</h1>

<p>The following examples are in csharp, but you can apply the concepts such as simple, compound, and secondary indexes to any language. For more information on indexes in JavaScript and Python, see <a class="xref" href="indexes-outside-dotnet.html">Indexes outside of .NET framework</a>.</p>
<h2 id="simple-indexes">Simple indexes</h2>
<p>When working in .NET, use the <code>SdsTypeBuilder</code> together with either the <code>OSIsoft.Sds.SdsMemberAttribute</code> (preferred) or the <code>System.ComponentModel.DataAnnotations.KeyAttribute</code> to identify the property that defines the simple index. Using the <code>SdsTypeBuilder</code> eliminates potential errors that might occur when working with SdsTypes manually.</p>
<pre><code class="lang-csharp">      public enum State
      {
        Ok,
        Warning,
        Alarm
      }

      public class Simple
      {
        [SdsMember(IsKey = true, Order = 0) ]
        public DateTime Time { get; set; }
        public State State { get; set; }
        public Double Measurement { get; set; }
      }

      SdsType simpleType = SdsTypeBuilder.CreateSdsType&lt;Simple&gt;();
</code></pre><p>To read data that is located between two indexes, define both a start index and an end index. For <code>DateTime</code>, use the ISO 8601 representation of dates and times. For example, to query for a window of simple values between January 1, 2010 and February 1, 2010, you can define indexes and query as follows:</p>
<pre><code class="lang-csharp">      IEnumerable&lt;Simple&gt; values = await
      client.GetWindowValuesAsync&lt;Simple&gt;(simpleStream.Id,
      &quot;2010-01-01T08:00:00.000Z&quot;,&quot;2010-02-01T08:00:00.000Z&quot;);
</code></pre><p>For more information about querying data, see <a class="xref" href="../read-data.html">Read data</a>.</p>
<h2 id="secondary-indexes">Secondary indexes</h2>
<p>Secondary indexes are defined at the stream level. To add indexes to a stream, add them to the stream <code>Indexes</code> field. For example, to add a second index on <code>Measurement</code>, use the following code:</p>
<pre><code class="lang-csharp">      SdsStreamIndex measurementIndex = new SdsStreamIndex()
      {
          SdsTypePropertyId = simpleType.Properties.First(p =&gt; p.Id.Equals(&quot;Measurement&quot;)).Id
      };
      SdsStream secondary = new SdsStream()
      {
          Id = &quot;Simple with Secondary&quot;,
          TypeId = simpleType.Id,
          Indexes = new List&lt;SdsStreamIndex&gt;()
          {
              measurementIndex
          }
      };
      secondary = await config.GetOrCreateStreamAsync(secondary);
</code></pre><p>To read data indexed by a secondary index, use a filtered <code>GET</code> method(<code>IEnumerable&lt;Simple&gt; orderedBySecondary = await client.GetFilteredValuesAsync&lt;Simple&gt;(secondary.Id,
      &quot;Measurement gt 0 and Measurement lt 6&quot;);</code>).</p>
<p>Use indexes to order data. On a stream level, you can set the property to be the secondary index. To improve performance when working with a large set of data:</p>
<ul>
<li><p>Ensure that the property is a secondary index.</p>
</li>
<li><p>Use <a class="xref" href="../read-data/filter-expressions.html#logical-operators">logical operators</a> for filtering.</p>
</li>
</ul>
<pre><code class="lang-csharp">      await client.UpdateValuesAsync&lt;Simple&gt;(secondary.Id, new List&lt;Simple&gt;()
        {
            new Simple()
            {
                Time = time,
                State = State.Ok,
                Measurement = 5
            },
            new Simple()
            {
                Time = time + TimeSpan.FromSeconds(1),
                State = State.Ok,
                Measurement = 4
            },
            new Simple()
            {
                Time = time + TimeSpan.FromSeconds(2),
                State = State.Ok,
                Measurement = 3
            },
            new Simple()
            {
                Time  = time + TimeSpan.FromSeconds(3),
                State = State.Ok,
                Measurement = 2
            },
            new Simple()
            {
                Time = time + TimeSpan.FromSeconds(4),
                State = State.Ok,
                Measurement = 1
            },
        });

      IEnumerable&lt;Simple&gt; orderedByKey = await client.GetWindowValuesAsync&lt;Simple&gt;(secondary.Id, 
          time.ToString(&quot;o&quot;), time.AddSeconds(4).ToString(&quot;o&quot;));
      foreach (Simple value in orderedByKey)
          Console.WriteLine(&quot;{0}: {1}&quot;, value.Time, value.Measurement);

      Console.WriteLine();

      IEnumerable&lt;Simple&gt; orderedBySecondary = await client.GetFilteredValuesAsync&lt;Simple&gt;(secondary.Id, 
      &quot;Measurement gt 0 and Measurement lt 6&quot;);
      foreach (Simple value in orderedBySecondary)
          Console.WriteLine(&quot;{0}: {1}&quot;, value.Time, value.Measurement);
      Console.WriteLine();

      // Output:
      // 1/20/2017 12:00:00 AM: 5
      // 1/20/2017 12:00:01 AM: 4
      // 1/20/2017 12:00:02 AM: 3
      // 1/20/2017 12:00:03 AM: 2
      // 1/20/2017 12:00:04 AM: 1
      //
      // 1/20/2017 12:00:04 PM: 1
      // 1/20/2017 12:00:03 PM: 2
      // 1/20/2017 12:00:02 PM: 3
      // 1/20/2017 12:00:01 PM: 4
      // 1/20/2017 12:00:00 PM: 5
</code></pre><h2 id="compound-indexes">Compound indexes</h2>
<p>Compound indexes are defined using the <code>SdsMemberAttribute</code> as follows:</p>
<pre><code class="lang-csharp">      public class Simple
      {
        [SdsMember(IsKey = true, Order = 0)]
        public DateTime Time { get; set; }
        public State State { get; set; }
        public Double Measurement { get; set; }
      }

      public class DerivedCompoundIndex : Simple
      {
        [SdsMember(IsKey = true, Order = 1)]
        public DateTime Recorded { get; set; } 
      }
</code></pre><p>Events of type <code>DerivedCompoundIndex</code> are sorted first by the <code>Time</code> parameter and then by the <code>Recorded</code> parameter. A collection of times is sorted as follows:</p>
<table>
<thead>
<tr>
<th><strong>Time</strong></th>
<th><strong>Recorded</strong></th>
<th><strong>Measurement</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>01:00</td>
<td>00:00</td>
<td>0</td>
</tr>
<tr>
<td>01:00</td>
<td>01:00</td>
<td>2</td>
</tr>
<tr>
<td>01:00</td>
<td>14:00</td>
<td>5</td>
</tr>
<tr>
<td>02:00</td>
<td>00:00</td>
<td>1</td>
</tr>
<tr>
<td>02:00</td>
<td>01:00</td>
<td>3</td>
</tr>
<tr>
<td>02:00</td>
<td>02:00</td>
<td>4</td>
</tr>
<tr>
<td>02:00</td>
<td>14:00</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>If the <code>Order</code> parameter was reversed, with <code>Recorded</code> set to 0 and <code>Time</code> set to 1, the results are sorted as follows:</p>
<table>
<thead>
<tr>
<th><strong>Time</strong></th>
<th><strong>Recorded</strong></th>
<th><strong>Measurement</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>01:00</td>
<td>00:00</td>
<td>0</td>
</tr>
<tr>
<td>02:00</td>
<td>00:00</td>
<td>1</td>
</tr>
<tr>
<td>01:00</td>
<td>01:00</td>
<td>2</td>
</tr>
<tr>
<td>02:00</td>
<td>01:00</td>
<td>3</td>
</tr>
<tr>
<td>02:00</td>
<td>02:00</td>
<td>4</td>
</tr>
<tr>
<td>01:00</td>
<td>14:00</td>
<td>5</td>
</tr>
<tr>
<td>02:00</td>
<td>14:00</td>
<td>6</td>
</tr>
</tbody>
</table>
<pre><code class="lang-csharp">      // estimates at 1/20/2017 00:00
      await client.UpdateValuesAsync(compoundStream.Id, new List&lt;DerivedCompoundIndex&gt;()
        {
            new DerivedCompoundIndex()
            {
                Time = DateTime.Parse(&quot;1/20/2017 01:00&quot;),
                Recorded = DateTime.Parse(&quot;1/20/2017 00:00&quot;),
                State = State.Ok,
                Measurement = 0
            },
            new DerivedCompoundIndex()
            {
                Time = DateTime.Parse(&quot;1/20/2017 02:00&quot;),
                Recorded = DateTime.Parse(&quot;1/20/2017 00:00&quot;),
                State = State.Ok,
                Measurement = 1
            },
        });

      // measure and estimates at 1/20/2017 01:00
      await client.UpdateValuesAsync(compoundStream.Id, new List&lt;DerivedCompoundIndex&gt;()
        {
            new DerivedCompoundIndex()
            {
                Time = DateTime.Parse(&quot;1/20/2017 01:00&quot;),
                Recorded = DateTime.Parse(&quot;1/20/2017 01:00&quot;),
                State = State.Ok,
                Measurement = 2
            },
            new DerivedCompoundIndex()
            {
                Time = DateTime.Parse(&quot;1/20/2017 02:00&quot;),
                Recorded = DateTime.Parse(&quot;1/20/2017 01:00&quot;),
                State = State.Ok,
                Measurement = 3
            },
        });

      // measure at 1/20/2017 02:00
      await client.UpdateValuesAsync(compoundStream.Id, new List&lt;DerivedCompoundIndex&gt;()
        {
            new DerivedCompoundIndex()
            {
                Time = DateTime.Parse(&quot;1/20/2017 02:00&quot;),
                Recorded = DateTime.Parse(&quot;1/20/2017 02:00&quot;),
                State = State.Ok,
                Measurement = 4
            },
        });

      // adjust earlier values at 1/20/2017 14:00
      await client.UpdateValuesAsync(compoundStream.Id, new List&lt;DerivedCompoundIndex&gt;()
        {
            new DerivedCompoundIndex()
            {
                Time = DateTime.Parse(&quot;1/20/2017 01:00&quot;),
                Recorded = DateTime.Parse(&quot;1/20/2017 14:00&quot;),
                State = State.Ok,
                Measurement = 5
            },
            new DerivedCompoundIndex()
            {
                Time = DateTime.Parse(&quot;1/20/2017 02:00&quot;),
                Recorded = DateTime.Parse(&quot;1/20/2017 14:00&quot;),
                State = State.Ok,
                Measurement = 6
            },
        });

      var from = new Tuple&lt;DateTime, DateTime&gt;(DateTime.Parse(&quot;1/20/2017 01:00&quot;), DateTime.Parse(&quot;1/20/2017 00:00&quot;));
      var to = new Tuple&lt;DateTime, DateTime&gt;(DateTime.Parse(&quot;1/20/2017 02:00&quot;), DateTime.Parse(&quot;1/20/2017 14:00&quot;));

      var compoundValues = await client.GetWindowValuesAsync&lt;DerivedCompoundIndex, DateTime, DateTime&gt;(compoundStream.Id, from, to);

      foreach (DerivedCompoundIndex value in compoundValues)
         Console.WriteLine(&quot;{0}:{1} {2}&quot;, value.Time, value.Recorded, value.Measurement);

      // Output:
      // 1/20/2017 1:00:00 AM:1/20/2017 12:00:00 AM 0
      // 1/20/2017 1:00:00 AM:1/20/2017 1:00:00 AM 2
      // 1/20/2017 1:00:00 AM:1/20/2017 2:00:00 PM 5
      // 1/20/2017 2:00:00 AM:1/20/2017 12:00:00 AM 1
      // 1/20/2017 2:00:00 AM:1/20/2017 1:00:00 AM 3
      // 1/20/2017 2:00:00 AM:1/20/2017 2:00:00 AM 4
      // 1/20/2017 2:00:00 AM:1/20/2017 2:00:00 PM 6
</code></pre><p><strong>Note:</strong> The <code>GetWindowValuesAsync()</code> call specifies an expected return type and the index types as generic parameters.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/osisoft/Edge-Data-Store-Docs/blob/main/content/sds/indexes/indexes-in-dotnet.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span><a href="https://www.osisoft.com/copyright/">© 2019 - 2021 OSIsoft, LLC. All rights reserved.</a></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
